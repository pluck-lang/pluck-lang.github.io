(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[726],{58325:function(e,n,r){Promise.resolve().then(r.bind(r,87627))},87627:function(e,n,r){"use strict";r.r(n),r.d(n,{default:function(){return a}});var i=r(3827),s=r(64090),o=r(29668),t={'code[class*="language-"]':{color:"#ccc",background:"none",fontFamily:"Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",fontSize:"1em",textAlign:"left",whiteSpace:"pre",wordSpacing:"normal",wordBreak:"normal",wordWrap:"normal",lineHeight:"1.5",MozTabSize:"4",OTabSize:"4",tabSize:"4",WebkitHyphens:"none",MozHyphens:"none",msHyphens:"none",hyphens:"none"},'pre[class*="language-"]':{color:"#ccc",background:"#2d2d2d",fontFamily:"Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace",fontSize:"1em",textAlign:"left",whiteSpace:"pre",wordSpacing:"normal",wordBreak:"normal",wordWrap:"normal",lineHeight:"1.5",MozTabSize:"4",OTabSize:"4",tabSize:"4",WebkitHyphens:"none",MozHyphens:"none",msHyphens:"none",hyphens:"none",padding:"1em",margin:".5em 0",overflow:"auto"},':not(pre) > code[class*="language-"]':{background:"#2d2d2d",padding:".1em",borderRadius:".3em",whiteSpace:"normal"},comment:{color:"#999"},"block-comment":{color:"#999"},prolog:{color:"#999"},doctype:{color:"#999"},cdata:{color:"#999"},punctuation:{color:"#ccc"},tag:{color:"#e2777a"},"attr-name":{color:"#e2777a"},namespace:{color:"#e2777a"},deleted:{color:"#e2777a"},"function-name":{color:"#6196cc"},boolean:{color:"#f08d49"},number:{color:"#f08d49"},function:{color:"#f08d49"},property:{color:"#f8c555"},"class-name":{color:"#f8c555"},constant:{color:"#f8c555"},symbol:{color:"#f8c555"},selector:{color:"#cc99cd"},important:{color:"#cc99cd",fontWeight:"bold"},atrule:{color:"#cc99cd"},keyword:{color:"#cc99cd"},builtin:{color:"#cc99cd"},string:{color:"#7ec699"},char:{color:"#7ec699"},"attr-value":{color:"#7ec699"},regex:{color:"#7ec699"},variable:{color:"#7ec699"},operator:{color:"#67cdcc"},entity:{color:"#67cdcc",cursor:"help"},url:{color:"#67cdcc"},bold:{fontWeight:"bold"},italic:{fontStyle:"italic"},inserted:{color:"green"}};function l(e){let{title:n,children:r,defaultOpen:o=!1}=e,[t,l]=(0,s.useState)(o);return(0,i.jsxs)("div",{className:"mb-4 border rounded-md",children:[(0,i.jsxs)("button",{className:"w-full text-left px-4 py-2 font-semibold bg-gray-100 hover:bg-gray-200 rounded-t-md focus:outline-none flex items-center justify-between",onClick:()=>l(e=>!e),"aria-expanded":t,children:[(0,i.jsx)("span",{children:n}),(0,i.jsx)("span",{className:"ml-2",children:t?"▲":"▼"})]}),t&&(0,i.jsx)("div",{className:"px-4 py-3 bg-white border-t",children:r})]})}function a(){let e=(0,s.useRef)(null),n=(0,s.useRef)(null),r=(0,s.useRef)(null),a=(0,s.useRef)(null),[c,d]=(0,s.useState)(null),h=(e,n)=>{d(e),setTimeout(()=>{var e;null===(e=n.current)||void 0===e||e.scrollIntoView({behavior:"smooth",block:"start"})},50)};return(0,i.jsxs)("div",{className:"prose prose-lg mx-auto max-w-2xl px-4 sm:px-6 lg:px-8",children:[(0,i.jsx)("h1",{children:"Using Pluck"}),(0,i.jsx)("p",{children:"Pluck is a probabilistic programming language designed for efficient inference on discrete probabilistic models. This guide will walk you through how to write Pluck programs and run queries, while showcasing several examples that demonstrate the language's capabilities."}),(0,i.jsx)("h2",{children:"Table of Contents"}),(0,i.jsxs)("ul",{children:[(0,i.jsx)("li",{children:(0,i.jsx)("a",{href:"#writing-a-basic-pluck-program",onClick:n=>{n.preventDefault(),h("writing",e)},children:"Writing a Basic Pluck Program"})}),(0,i.jsx)("li",{children:(0,i.jsx)("a",{href:"#running-a-pluck-program",onClick:e=>{e.preventDefault(),h("running",n)},children:"Running a Pluck Program"})}),(0,i.jsx)("li",{children:(0,i.jsx)("a",{href:"#language-reference",onClick:e=>{e.preventDefault(),h("lang",r)},children:"Language Reference"})}),(0,i.jsx)("li",{children:(0,i.jsx)("a",{href:"#sharp-edges",onClick:e=>{e.preventDefault(),h("sharp",a)},children:"Sharp Edges"})})]}),(0,i.jsx)("div",{ref:e,id:"writing-a-basic-pluck-program",children:(0,i.jsxs)(l,{title:"Writing a Basic Pluck Program",defaultOpen:"writing"===c,children:[(0,i.jsxs)("p",{children:["A Pluck program consists of a sequence of ",(0,i.jsx)("em",{children:"top-level forms"}),", which may be:"]}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["type definitions (using ",(0,i.jsx)("code",{children:"define-type"}),"),"]}),(0,i.jsxs)("li",{children:["function definitions (using ",(0,i.jsx)("code",{children:"define"}),"), and"]}),(0,i.jsxs)("li",{children:["queries (using ",(0,i.jsx)("code",{children:"query"}),")."]})]}),(0,i.jsx)("p",{children:"For example, the following program defines a function and queries the probability that it returns a value greater than five:"}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:";; Define a function with parameter p.\n(define (generate-number p) \n  ;; (geom p) samples from a geometric distribution\n  ;; with parameter p.\n  (+ (geom p) (geom 0.2)))\n\n;; Example query:\n(query\n  num-greater-than-five\n  (Marginal \n    (> (generate-number 0.7) 5)))\n\n;; Posterior query:\n(query \n  posterior-given-less-than-five \n  (let ((n (generate-number 0.7)))\n    (Posterior \n      n \n      (< n 5))))"})]})}),(0,i.jsx)("div",{ref:n,id:"running-a-pluck-program",children:(0,i.jsxs)(l,{title:"Running a Pluck Program",defaultOpen:"running"===c,children:[(0,i.jsx)("p",{children:"To compile a Pluck file, open Julia and run:"}),(0,i.jsx)(o.Z,{language:"julia",style:t,children:'julia> using Pkg; Pkg.activate("."); instantiate\njulia> using Pluck\njulia> load_pluck_file("programs/simple_example.pluck");'}),(0,i.jsxs)("p",{children:["All definitions will be loaded into the top-level environment, and the results of each query in ",(0,i.jsx)("code",{children:"simple_example.pluck"})," will be printed to the console."]})]})}),(0,i.jsx)("div",{ref:r,id:"language-reference",children:(0,i.jsxs)(l,{title:"Language Reference",defaultOpen:"lang"===c,children:[(0,i.jsx)("h4",{children:"Syntax"}),(0,i.jsxs)("p",{children:["A ",(0,i.jsx)("strong",{children:"program"})," is a sequence of ",(0,i.jsx)("strong",{children:"top-level forms."})]}),(0,i.jsxs)("p",{children:["A ",(0,i.jsx)("strong",{children:"top-level form"})," is one of:"]}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"value definition"})," of the form ",(0,i.jsx)("code",{children:"(define <var> <expr>)"})]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"function definition"})," of the form ",(0,i.jsx)("code",{children:"(define (<func-name> <arg-1> ... <arg-n>) <expr>)"}),"."]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"type definition"})," of the form ",(0,i.jsx)("code",{children:"(define-type <type-name> (<constructor-1> <arg1-1> ... <arg1-n>) ... (<constructor-m> <argm-1> ... <argm-k>))"}),"."]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"query"})," of the form ",(0,i.jsx)("code",{children:"(query <query-name> <expr>)"}),"."]})]}),(0,i.jsxs)("p",{children:["An ",(0,i.jsx)("strong",{children:"expression"})," is one of:"]}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"variable"})," ",(0,i.jsx)("code",{children:"<var>"})]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"let-expression"})," ",(0,i.jsx)("code",{children:"(let ((<var> <expr>) ...) <expr>)"})]}),(0,i.jsxs)("li",{children:["an ",(0,i.jsx)("strong",{children:"if-then-else expression"})," ",(0,i.jsx)("code",{children:"(if <expr> <expr> <expr>)"})]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"match expression"})," of the form:"]})]}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:"(match <expr>\n  <constructor-1> <var-1-1> ... <var-1-n> => <expr-1>\n  ...\n  <constructor-m> <var-m-1> ... <var-m-k> => <expr-m>)"}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:["an ",(0,i.jsx)("strong",{children:"anonymous function"})," ",(0,i.jsx)("code",{children:"(lambda <arg1> ... <argn> -> <expr>)"})]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"constructor expression"})," ",(0,i.jsx)("code",{children:"(<constructor> <expr-1> ... <expr-n>)"})]}),(0,i.jsxs)("li",{children:["an ",(0,i.jsx)("strong",{children:"application"})," ",(0,i.jsx)("code",{children:"(<expr> <expr-1> ... <expr-n>)"})]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"floating-point or natural-number constant"})," ",(0,i.jsx)("code",{children:"<const>"})]}),(0,i.jsxs)("li",{children:["a ",(0,i.jsx)("strong",{children:"random primitive"})," expression, e.g. ",(0,i.jsx)("code",{children:"(flip <expr>)"}),", ",(0,i.jsx)("code",{children:"(uniform ...)"}),", ",(0,i.jsx)("code",{children:"(discrete ...)"})]})]}),(0,i.jsx)("h4",{children:"Defining and Using Algebraic Datatypes"}),(0,i.jsxs)("p",{children:["New (recursive) algebraic data types can be defined using the syntax ",(0,i.jsx)("code",{children:"(define-type <type-name> (<constructor> <arg-type>...) ...)"}),". Note that currently, because the Pluck implementation is untyped, the ",(0,i.jsx)("code",{children:"<arg-type>"}),"s can be instantiated with any symbol, and primarily convey user intent. (However, the arity of each constructor is determined by the number of listed arguments.)"]}),(0,i.jsx)("p",{children:"Several types are built in:"}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:";; Tuple type\n(define-type pair (Pair any any))\n;; Natural numbers -- either zero (O) or successor (S nat)\n(define-type nat (O) (S nat))\n;; Unit type\n(define-type unit (Unit))\n;; Boolean type\n(define-type bool (True) (False))\n;; List type\n(define-type list (Nil) (Cons any list))"}),(0,i.jsxs)("p",{children:["To construct a value of an algebraic datatype, use the syntax ",(0,i.jsx)("code",{children:"(<constructor> <arg-1> ... <arg-n>)"}),". For instance, a tuple is constructed as ",(0,i.jsx)("code",{children:"(Pair e1 e2)"})," and a list as ",(0,i.jsx)("code",{children:"(Cons 3 (Cons 2 (Nil)))"}),". Natural number literals are automatically parsed as repeated applications of the ",(0,i.jsx)("code",{children:"nat"})," constructors (e.g. ",(0,i.jsx)("code",{children:"2"})," is automatically converted into ",(0,i.jsx)("code",{children:"(S (S (O)))"}),")."]}),(0,i.jsx)("p",{children:"Algebraic datatypes support pattern matching using the syntax:"}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:"(match <scrutinee> \n  <constructor1> <var1-1> ... <var1-n>  => <expr1>\n  <constructor2> <var2-1> ... <var2-m> => <expr2>\n  ...)"}),(0,i.jsx)("p",{children:"For example, the standard library implements several functions for processing the built-in types:"}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:";; Extract first element from a pair\n(define (fst pair)\n  (match pair\n    Pair a b => a))\n\n;; Extract second element from a pair\n(define (snd pair)\n  (match pair\n    Pair a b => b))\n\n;; Map a function over a list\n(define (map f l)\n  (match l\n    Nil => (Nil)\n    Cons x xs => (Cons (f x) (map f xs))))"}),(0,i.jsxs)("p",{children:["Note that all patterns have a single constructor and then one variable per argument. Nested patterns are not supported (e.g. you ",(0,i.jsx)("em",{children:"cannot"})," match against ",(0,i.jsx)("code",{children:"(Cons x (Nil))"}),'). There is no "else" pattern.']}),(0,i.jsxs)("p",{children:["Several built-in functions exist for equality comparison. The ",(0,i.jsx)("code",{children:"constructor=?"})," function accepts two arguments, both of some algebraic datatype, and checks whether they have the same constructor. The function ",(0,i.jsx)("code",{children:"=="})," compares natural numbers. The function ",(0,i.jsx)("code",{children:"list=?"})," takes three arguments: a predicate for comparing elements of the lists, and two lists. For example, ",(0,i.jsx)("code",{children:"(list=? ==)"})," is an equality predicate for lists of natural numbers."]}),(0,i.jsx)("h4",{children:"Defining and Using Functions"}),(0,i.jsxs)("p",{children:["The top-level form ",(0,i.jsx)("code",{children:"(define (<func-name> <arg-1> ... <arg-n>) <body>)"})," can be used to define new functions. Anonymous functions can be defined using ",(0,i.jsx)("code",{children:"lambda"}),": ",(0,i.jsx)("code",{children:"(lambda <arg-1> ... <arg-n> -> <body>)"}),". All multi-argument functions are automatically curried, and ",(0,i.jsx)("code",{children:"(f x y z)"})," is sugar for ",(0,i.jsx)("code",{children:"(((f x) y) z)"}),"."]}),(0,i.jsxs)("p",{children:["As sugar, ",(0,i.jsx)("code",{children:"(define (<fname>) <body>)"}),", ",(0,i.jsx)("code",{children:"(lambda -> <body>)"}),", and ",(0,i.jsx)("code",{children:"(<expr>)"})," can be used as shorthand for ",(0,i.jsx)("code",{children:"(define (<fname> _) <body>)"}),", ",(0,i.jsx)("code",{children:"(lambda _ -> <body>)"}),", and ",(0,i.jsx)("code",{children:"(<expr> (Unit))"}),", respectively."]}),(0,i.jsxs)("p",{children:["Functions defined with ",(0,i.jsx)("code",{children:"define"})," may use any previously defined name in their body, including the name being defined (for recursive definitions). Anonymous recursive functions can be defined using the built-in Y-combinator ",(0,i.jsx)("code",{children:"(Y (lambda <fname> <arg-1> ... <arg-n> -> <body>))"}),". We do not have special syntax for mutually recursive functions, but it is possible to define them using ",(0,i.jsx)("code",{children:"Pair"}),", e.g.:"]}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:"(define even-and-odd\n  (let ((even (fst even-and-odd)) \n        (odd  (snd even-and-odd)))\n    (Pair \n      (lambda n => \n        (match n\n          O => (True)\n          S m => (odd m)))\n      (lambda n => \n        (match n \n          O => (False)\n          S m => (even m))))))\n(define even (fst even-and-odd))\n(define odd (snd even-and-odd))"}),(0,i.jsxs)("p",{children:["In general, ",(0,i.jsx)("code",{children:"define"})," is intended to be used for ",(0,i.jsx)("em",{children:"function"})," definitions, and possibly other deterministic constants. Evaluating a definition should not require making random choices (e.g. do ",(0,i.jsx)("strong",{children:"not"})," write ",(0,i.jsx)("code",{children:"(define b (flip 0.5))"}),"); intuitively, random choices are tracked when they happen while evaluating queries, either because the query expression itself makes random choices or because it calls previously defined functions that do."]}),(0,i.jsx)("h4",{children:"Queries"}),(0,i.jsxs)("p",{children:["Query expressions have the form ",(0,i.jsx)("code",{children:"(query <name> <expr>)"}),", where the expression must evaluate to a value of type ",(0,i.jsx)("code",{children:"query"}),". The query type has three constructors, which correspond to three kinds of query you can execute:"]}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("code",{children:"(Marginal <expr>)"}),": compute the full marginal distribution over possible values that ",(0,i.jsx)("code",{children:"<expr>"})," can take on."]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("code",{children:"(Posterior <expr> <bool-expr>)"}),": compute the posterior distribution over possible values that ",(0,i.jsx)("code",{children:"<expr>"})," can take on, given that ",(0,i.jsx)("code",{children:"<bool-expr>"})," is true."]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("code",{children:"(PosteriorSamples <expr> <bool-expr> <nat-expr>)"}),": generate ",(0,i.jsx)("code",{children:"<nat-expr>"})," samples from the posterior distribution over possible values that ",(0,i.jsx)("code",{children:"<expr>"})," can take on, given that ",(0,i.jsx)("code",{children:"<bool-expr>"})," is true."]})]}),(0,i.jsx)("p",{children:"A query commonly has the form:"}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:"(query\n  <name>\n  (let \n    ((x <expr>)\n     (y <expr>)\n     ...)\n  (Posterior\n    <some-expr-involving-local-vars>\n    <some-expr-involving-local-vars>)))"}),(0,i.jsxs)("p",{children:["A query expression should not require using randomness to figure out what the query is, e.g. ",(0,i.jsx)("code",{children:"(query my-bad-query (if (flip 0.5) (Marginal ...) (Posterior ...)))"})," will result in an error."]}),(0,i.jsx)("h4",{children:"Primitive Distributions"}),(0,i.jsxs)("p",{children:["The key primitive for random sampling is ",(0,i.jsx)("code",{children:"flip"}),", which takes in a floating-point number ",(0,i.jsx)("code",{children:"p"})," and returns ",(0,i.jsx)("code",{children:"(True)"})," with probability ",(0,i.jsx)("code",{children:"p"}),", and ",(0,i.jsx)("code",{children:"(False)"})," with probability ",(0,i.jsx)("code",{children:"1-p"}),"."]}),(0,i.jsxs)("p",{children:["The constructs ",(0,i.jsx)("code",{children:"(uniform e1 ... en)"})," and ",(0,i.jsx)("code",{children:"(discrete (e1 p1) ... (en pn))"}),' are macros that the compiler automatically expands into "decision trees" of coin flips. In ',(0,i.jsx)("code",{children:"flip"}),", the argument ",(0,i.jsx)("code",{children:"p"})," can be a dynamically determined value, but in ",(0,i.jsx)("code",{children:"discrete"}),", the probabilities must be constant floating-point literals that sum to 1. So, ",(0,i.jsx)("code",{children:"(flip (if b 0.2 0.7))"})," is OK, but ",(0,i.jsx)("code",{children:"(discrete (x (if b 0.2 0.7)) (y (if b 0.8 0.3)))"})," is not; write ",(0,i.jsx)("code",{children:"(if b (discrete (x 0.2) (y 0.8)) (discrete (x 0.7) (y 0.3)))"})," instead."]}),(0,i.jsxs)("p",{children:["The geometric distribution is defined in the standard library, using ",(0,i.jsx)("code",{children:"flip"}),", and thus can accept a dynamic argument:"]}),(0,i.jsx)(o.Z,{language:"scheme",style:t,children:";; geometric distribution\n(define (geom p)\n  (if (flip p)\n    (O)\n    (S (geom p))))"})]})}),(0,i.jsx)("div",{ref:a,id:"sharp-edges",children:(0,i.jsxs)(l,{title:"Sharp Edges",defaultOpen:"sharp"===c,children:[(0,i.jsx)("h4",{children:"Termination and Non-termination"}),(0,i.jsxs)("p",{children:["Executing a query may lead to non-termination. Each query has different requirements for termination, but they all rest on the notion of ",(0,i.jsx)("em",{children:"lazy sure termination."})]}),(0,i.jsxs)("p",{children:["Intuitively, an expression ",(0,i.jsx)("code",{children:"e"})," lazily surely terminates if ",(0,i.jsx)("code",{children:"(print e)"}),", when executed by a lazy (call-by-need) interpreter, terminates for every possible random seed."]}),(0,i.jsxs)("p",{children:["As an example, ",(0,i.jsx)("code",{children:"(geom 0.5)"})," is ",(0,i.jsx)("em",{children:"not"})," lazily surely terminating, because there is a seed on which it never halts (where every ",(0,i.jsx)("code",{children:"flip"})," comes up tails). But ",(0,i.jsx)("code",{children:"(< (geom 0.5) 10)"})," is lazily surely terminating, because lazy evaluation only looks at (at most) the first 11 coin flips before halting."]}),(0,i.jsx)("p",{children:"By query, the requirements for termination are as follows:"}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("code",{children:"(Marginal <expr>)"})," terminates if ",(0,i.jsx)("code",{children:"<expr>"})," is lazily surely terminating."]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("code",{children:"(Posterior <expr> <bool>)"})," terminates if ",(0,i.jsx)("code",{children:"(if <bool> <expr> (Unit))"})," lazily surely terminates."]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("code",{children:"(PosteriorSamples <expr> <bool> <nat>)"})," terminates (with probability 1) if ",(0,i.jsx)("code",{children:"<bool>"})," lazily surely terminates and ",(0,i.jsx)("code",{children:"(if <bool> <expr> (Unit))"})," lazily ",(0,i.jsx)("em",{children:"almost"})," surely terminates (i.e., terminates for all but a probability-0 set of random seeds)."]})]}),(0,i.jsx)("p",{children:"If you run a non-terminating query, using Ctrl+C inside the Julia REPL should cancel the query without exiting the Julia REPL."}),(0,i.jsx)("h4",{children:"Overwriting Prelude Definitions"}),(0,i.jsxs)("p",{children:["Consider the type definition ",(0,i.jsx)("code",{children:"(define-type non-terminal (S) (V) (N) (Adj) (V) (NP) (VP))"})," that you might see in a definition of a probabilistic grammar for English. A subtle issue is that ",(0,i.jsx)("code",{children:"S"})," is already a constructor defined by Pluck's prelude/standard library, for the successor of a natural number. Pluck allows the user to silently overwrite the definition of ",(0,i.jsx)("code",{children:"S"}),", but all built-in functions relying on natural numbers no longer work, leading to runtime errors. A similar case to watch out for is ",(0,i.jsx)("code",{children:"Y"}),", which is the Y combinator."]}),(0,i.jsx)("h4",{children:"Stack Overflows"}),(0,i.jsx)("p",{children:"Pluck's compiler is currently implemented recursively in Julia, and programs that are themselves recursive and make deeply nested function calls may lead to stack overflows. This will cause the query to fail but the Julia REPL should stay alive, so it is possible to edit the program and try again. We are hoping to implement optimizations to prevent this in the near future."}),(0,i.jsx)("h4",{children:"Performance Considerations"}),(0,i.jsx)("p",{children:"In addition to non-terminating queries, it is also possible to write queries that run very slowly."}),(0,i.jsxs)("ul",{children:[(0,i.jsxs)("li",{children:[(0,i.jsx)("strong",{children:"Lazy evaluation."})," Pluck uses laziness to help prune the space of program executions it needs to explore. A good rule of thumb is to try to write query expressions and posterior conditioning predicates so that a lazy interpreter would be able to return the result of the query expression or predicate after generating only a small fraction of the data structure to which it is being applied. Similarly, it is useful to write the probabilistic programs themselves in such a way that they generate data lazily if possible, computing (e.g.) the first element of a list before the second."]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("strong",{children:"Variable order"}),": Knowledge compilation, the technique that powers Pluck's inference, builds ",(0,i.jsx)("em",{children:"binary decision diagrams"})," to represent a program's semantics. The performance of these BDDs can be sensitive to the ",(0,i.jsx)("em",{children:"variable order"}),"--an ordering on all the random choices a program makes. Queries that run quickly under one variable order can become exponentially slow under another."]}),(0,i.jsxs)("li",{children:[(0,i.jsx)("strong",{children:"Repeated sub-expressions"}),": An expression like ",(0,i.jsx)("code",{children:"(+ (f x) (f x))"})," is not in general equivalent to ",(0,i.jsx)("code",{children:"(let ((y (f x))) (+ y y))"}),", because ",(0,i.jsx)("code",{children:"f"})," may make random choices; the first expression performs the random choices twice (independently) whereas the second performs them only once. However, if the shared sub-expression appears in a branch, e.g. ",(0,i.jsx)("code",{children:"(if (flip 0.4) (+ 3 (f x)) (* 2 (f x)))"}),", it is recommended to assign a single variable for use in both branches: ",(0,i.jsx)("code",{children:"(let ((y (f x))) (if (flip 0.4) (+ 3 y) (* 2 y)))"}),". This does not change the distribution denoted by the program, but operationally, allows us to create a single thunk for ",(0,i.jsx)("code",{children:"(f x)"}),", rather than two."]})]})]})})]})}}},function(e){e.O(0,[668,971,69,744],function(){return e(e.s=58325)}),_N_E=e.O()}]);